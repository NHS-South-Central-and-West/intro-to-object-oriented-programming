{
  "hash": "3db56934edf652ea51f921bfe1cfb00a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Introduction to Object-Oriented Programming\"\nauthor: \"Edward Chick\"\nhighlight-style: github\n---\n\n\n## Learning Objectives\n- Understand core concepts of object-oriented programming\n- Understand the benefits of object-oriented programming\n- Learn how to create your own object classes\n\n## History\n- In the early days of programming, variables could only be the \"primitive\" data types containing a single value\n  - Integer, Float, Boolean, Char\n- Later came Structures (\"Structs\"), which can contain multiple values of different types.\n- Structs were the precursor to objects, but they couldn't yet contain associated functions within them\n- Objects first appear in the Simula programming language in the 1960s for modelling physical phenomena\n- Those objects influenced Alan Kay, who coined the term \"object-oriented programming\" to decribe architecture where objects pass information to one another\n\n\n## Fast-forward to the present day\n- Python is an object-oriented language, where everything is effectively an object based on class \"templates\"\n\n::: {#533f837d .cell execution_count=1}\n``` {.python .cell-code}\n# Here we are calling the \"append\" method of the list class.\n\nicb_list = ['QRL','QNQ','QU9','QSL'] # a list object\n\nicb_list.append('QNX') # calling the method and passing a parameter\n\nprint(icb_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['QRL', 'QNQ', 'QU9', 'QSL', 'QNX']\n```\n:::\n:::\n\n\n- Since Python is an object-oriented language, there's no reason not to create our own classes!\n\n## Key Benefits\n- Useful for modelling real-world entities (e.g. simulations of hospital wards to solve queuing problems)\n- Makes code more re-usable and extensible\n- Simplifies the programmer's interaction with a program\n- Simplifies the interaction between different parts of a program\n\n# Key Concepts {data-background-color=\"#425563\"}\n[- Classes - Objects]{style=\"color: #E8EDEE\"}\\\n[- Encapsulation - Inheritance - Polymorphism - Abstraction]{style=\"color: #E8EDEE\"}\n\n## Classes and Objects\n- Classes act as **templates** for objects\n- Objects are instances of classes\n  - We talk of objects being \"instantiated\" from a class\n- Objects represent entities with their own data (attributes) and behaviours (methods)\n- We can create lots of instances of an object with their own attribute values and call methods on them separately\nand _consistently_\n- Objects are self-contained units that can interact with objects both of the same and of other classes\n\n# The Anatomy of Classes and Objects {data-background-color=\"#425563\"}\n\n---\n\n![A diagram representing a class at the top and object instances created from the class](images/classes1.png){fig-align=\"center\"}\n\n---\n\n## A quick note on _constructors_\n\n- The constructor method defines the attributes specific to an object instance when it is created (instantiated)\n- As the method name `__init__` suggests, these are the _initial_ values\n- It does not affect anything defined as a class attribute\n\n![](images/village_people_construction_worker.jpg){fig-align=\"center\"}\n\n---\n\n[**Python code for creating a class**]{style=\"color: #005EB8\"}\n\n::: {#52add3e2 .cell execution_count=2}\n``` {.python .cell-code}\n# Use the \"class\" keyword. Class names should start with a \n# capital letter\nclass HealthProfessional:\n  # Class attributes go here. The value of this attribute \n  # will be the same for all object instances\n  daily_capacity = 7.5 # number of working hours per day\n\n  # Constructor method. It always contains \"self\" followed by \n  # the parameters passed at instantiation\n  def __init__(self, assignment_number, division, department):\n    self.assignment_number = assignment_number                 \n    self.division = division                  # Instance attributes                \n    self.department = department                              \n\n  # Class methods. Always have at least \"self\" as a parameter, \n  # followed by any parameters passed to the object\n  def treat_patient(self,patient_id):\n    print(f'Health professional {self.assignment_number} treated patient {patient_id}')\n\n\n# Let's instantiate a HealthProfessional\ndoctor_duggee = HealthProfessional(12345,\"A\",\"Surgery\")\n\n# Using the .treat_patient() method\ndoctor_duggee.treat_patient(\"Betty\")\n\n# Accessing the object's attributes\nprint(f'Health Professional {doctor_duggee.assignment_number} works in the {doctor_duggee.department} department')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHealth professional 12345 treated patient Betty\nHealth Professional 12345 works in the Surgery department\n```\n:::\n:::\n\n\n---\n\n## Inheritance\n- **Child classes inherit attributes and methods from parent classes**\n- Child classes can modify / override and add to what they have inherited\n- Reduces code duplication\n- Improves re-usability and extensibility\n\n---\n\n\n![A parent class (green) and two different child classes (blue and orange), each with objects created from them](images/classes2.png){fig-align=\"center\"}\n\n---\n\n[**Python code for creating a child class from a parent class**]{style=\"color: #005EB8\"}\n\n::: {#b32224b9 .cell execution_count=3}\n``` {.python .cell-code}\n# Create the parent class\nclass HealthProfessional:\n\n  daily_capacity = 7.5 \n\n  def __init__(self, assignment_number, division, department):\n    self.assignment_number = assignment_number\n    self.division = division\n    self.department = department\n\n  def treat_patient(self,patient_id):\n    print(f'Health professional {self.assignment_number} treated patient {patient_id}')\n\n# Create the child class\n# The parent class goes in parentheses after the child class name\nclass Doctor(HealthProfessional):\n  def __init__(self,assignment_number,division,department,seniority):\n    self.seniority = seniority\n    super().__init__(assignment_number,division,department)\n\n  def discharge_patient(self,patient_id):\n    print(f'Doctor {self.assignment_number} discharged patient {patient_id}')\n\n# The \"treat_patient\" method is inherited from HealthProfessional\n\ndoctor_duggee = Doctor(12345,\"A\",\"Sugery\",\"Consultant\")\n\ndoctor_duggee.treat_patient(\"Betty\")\ndoctor_duggee.discharge_patient(\"Betty\")\nprint(f'Doctor {doctor_duggee.assignment_number} is a {doctor_duggee.seniority}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHealth professional 12345 treated patient Betty\nDoctor 12345 discharged patient Betty\nDoctor 12345 is a Consultant\n```\n:::\n:::\n\n\n# More Object-Oriented Programming Concepts{data-background-color=\"#425563\"}\n\n## Encapsulation\n- **Bundling data (attributes) with functions (methods)**\n- Methods are tailor-made to work with the data contained in the object\n- Saves on having to pass data between multiple functions, which is particularly useful in machine learning models\n- Pandas DataFrames demonstrate encapsulation. They contain data, but also have methods associated with them\n  - `df = pd.DataFrame(data)` <-- Instantiating a dataframe object\n  - `df.head()`, `df.describe()`, `df.drop()` <-- calling methods\n\n## Polymorphism\n- **Objects of different types can be treated in the same way, even if the behaviour differs**\n  - With Pandas DataFrames, .head() will work on both a DataFrame and a Series^[Series.head() with return the first few values, \n  while DataFrame.head() returns the first few rows of all columns]\n- \"Duck typing\": If the behaviour of a thing matches that of another thing, they are considered the same. In OOP terms, \nthe presence of certain methods is more important than which class an object comes from^[The concept of \"duck typing\", found \nin Python and other languages, comes from the phrase \"if it walks like a duck, quacks like a duck and swims like a duck,\nthen it's a duck.\"]\n  - The sci-kit learn library's allows the same code to work for different models\n\n---\n\n```\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC\n\nmodels = [LogisticRegression(), SVC()]\nfor model in models:\n    model.fit(X_train, y_train) # Both have .fit() method\n    preds = model.predict(X_test) # Both have .predict() method\n\n```\n\n---\n\n## Abstraction\n- **Separating the implementation code from the functionality that users (i.e. other programmers) interact with**\n- Creates a simple interface for parts of a program pass information between each other\n\n## When to use OOP\n- When you want to easily re-use code, to avoid repetition and to extend functionality\n- When you want to model real-world entities\n- When you want to make code modular and easy for others to work with\n- **Less appropriate for:**When you want to be certain of the state of your data at each step of a process, for example when cleansing data\n\n## Resources\n\n[RealPython: Object-Oriented Programming (OOP) in Python](https://realpython.com/python3-object-oriented-programming/)\\\n\\\n[freeCodeCamp - Intro to Object-Oriented Programming](https://www.youtube.com/watch?v=SiBw7os-_zI)\\\n\\\n[HSMA - Introduction to Python Programming Part 3 (including OOP)](https://github.com/hsma-programme/1e_python_programming_part_3/blob/main/1E_Python_Programming_Part_3/1E_web_Python_Prog_Part_3.pdf)\\\n\\\n[HSMA - Introduction to Discrete Event Simulation](https://github.com/hsma-programme/h6_2a_intro_to_des)\n\n---\n\n![Well done, Squirrels, you've earned your Object-Oriented Programming Badge!](images/oop_badge.png){fig-align=\"center\"}\n\n",
    "supporting": [
      "introduction_to_oop_files"
    ],
    "filters": [],
    "includes": {}
  }
}